var p=Object.defineProperty;var x=(e,r,a)=>r in e?p(e,r,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[r]=a;var t=(e,r,a)=>x(e,typeof r!="symbol"?r+"":r,a);import{aW as f,aX as y,aY as M,aZ as i,a_ as m,a$ as o,b0 as u}from"./CArnVfK8.js";import{r as P,a as $}from"./VqKbxEJf.js";const l=e=>{const r=e[1],a=e[0].indexOf(r);return[a,a+r.length]};class R extends y{constructor(){super(...arguments);t(this,"objectRegexp",/^@math$([\S\s]+)/m);t(this,"dollarRegexp",/^\$\$([\S\s]+?)\$\$$/m);t(this,"range")}canParse(a){const s=(h,d)=>{const n=h.exec(d);return n&&n.index===0?n:!1};let c=s(this.objectRegexp,a)||s(this.dollarRegexp,a);return c?(this.range=l(c),!0):!1}async createParseData(a){return{src:a,range:this.range}}}class S extends M{constructor(){super(...arguments);t(this,"regexp",/\$([^\$]+)\$/g)}async parseDataFromRegexp(a){return{src:a[0],range:l(a)}}}class g extends f{async stringifyElement(){const{parseData:r}=this.payload();return r.src}}const k=i({Node:m,Parsers:[R],Stringifier:g,async createPreRenderData(e){return P(o(e))}}),I=i({Node:u,Parsers:[S],Stringifier:g,async createPreRenderData(e){return $(o(e))}});export{k as blockMathTranspiler,I as inlineMathTranspiler};
